//@ sourceMappingURL=osiris.map
// Generated by CoffeeScript 1.6.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  $(function() {
    var AggregateQuestion, CountQuestion, OpenSpendingAPI, OrderTrait, Question, SearchQuestion, TotalAmount, Trait, Who, WhoMax, WhoMaxWhich, WhoMin, WhoMinWhich, YearFilter, answerQuestion, api, current, datasetUrl, findInMapping, findLeastLevenshtein, findQuestion, getCurrenySpeak, getModel, getTime, modelCache, questions, timeCache, trim;
    datasetUrl = "http://openspending.org/datasets.json";
    trim = function(str) {
      return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    };
    OpenSpendingAPI = (function() {

      function OpenSpendingAPI(apiUrl) {
        this.apiUrl = apiUrl;
      }

      OpenSpendingAPI.prototype.get = function(url, options) {
        var d;
        url = url + '?' + $.param(options);
        d = $.Deferred();
        $.getJSON(url, function(data) {
          return d.resolve(data);
        });
        return d.promise();
      };

      OpenSpendingAPI.prototype.aggregate = function(dataset, options) {
        var k, v;
        options = $.extend({}, options);
        options.dataset = dataset;
        options.drilldown = options.drilldown || [];
        options.drilldown = options.drilldown.join('|');
        options.cut = options.cut || {};
        options.cut = [
          (function() {
            var _ref, _results;
            _ref = options.cut;
            _results = [];
            for (k in _ref) {
              v = _ref[k];
              _results.push(k + ':' + v);
            }
            return _results;
          })()
        ];
        options.cut = options.cut.join('|');
        return this.get(this.apiUrl + 'aggregate', options);
      };

      OpenSpendingAPI.prototype.search = function(dataset, options) {
        var k, v;
        options.dataset = dataset;
        options.filter = options.filter || {};
        options.filter = [
          (function() {
            var _ref, _results;
            _ref = options.filter;
            _results = [];
            for (k in _ref) {
              v = _ref[k];
              _results.push(k + ':' + v);
            }
            return _results;
          })()
        ];
        options.filter = options.filter.join('|');
        return this.get(this.apiUrl + 'search', options);
      };

      return OpenSpendingAPI;

    })();
    api = new OpenSpendingAPI("http://openspending.org/api/2/");
    modelCache = {};
    timeCache = {};
    getModel = function(dataset, options) {
      var d, url;
      url = "http://openspending.org/" + dataset + "/model.json";
      d = $.Deferred();
      if (modelCache[dataset]) {
        return modelCache[dataset];
      } else {
        $.getJSON(url, function(data) {
          modelCache[dataset] = data;
          return d.resolve(modelCache[dataset]);
        });
      }
      return d.promise();
    };
    getTime = function(dataset, options) {
      var d, url;
      url = "http://openspending.org/" + dataset + "/time.distinct.json";
      d = $.Deferred();
      if (timeCache[dataset]) {
        return timeCache[dataset];
      } else {
        $.getJSON(url, function(data) {
          var i, times;
          times = {};
          i = 0;
          while (i < data.results.length) {
            times[data.results[i].year] = true;
            i += 1;
          }
          timeCache[dataset] = times;
          return d.resolve(timeCache[dataset]);
        });
      }
      return d.promise();
    };
    getCurrenySpeak = function(currency) {
      var trans;
      trans = {
        USD: "US Dollar",
        AUD: "Australian Dollar",
        EUR: "Euro",
        GBP: "Pound Sterling"
      };
      return trans[currency] || currency;
    };
    findInMapping = function(current, origname) {
      var key, name, trans, transforms, value, _i, _len, _ref;
      name = trim(origname.toLowerCase());
      transforms = [
        function(name) {
          return name = trim(origname.toLowerCase());
        }, function(name) {
          name = name.replace(/ies$/, 'y');
          return name = name.replace(/s$/, '');
        }, function(name) {
          return name = name.split(' ')[0];
        }, function(name) {
          name = name.replace(/ies$/, 'y');
          return name = name.replace(/s$/, '');
        }
      ];
      for (_i = 0, _len = transforms.length; _i < _len; _i++) {
        trans = transforms[_i];
        name = trans(name);
        _ref = current.model.mapping;
        for (key in _ref) {
          value = _ref[key];
          if (name === key.toLowerCase()) {
            return key;
          }
          if (value.label && name === value.label.toLowerCase()) {
            return key;
          }
          if (name.indexOf(key.toLowerCase()) === 0) {
            return key;
          }
          if (value.label && name.indexOf(value.label.toLowerCase()) === 0) {
            return key;
          }
        }
        if (name.indexOf('recipient') === 0) {
          return "to";
        }
        if (name.indexOf('spender') === 0) {
          return "from";
        }
      }
      throw new Error(origname + ' is not a dimension');
    };
    Trait = (function() {

      function Trait(current) {
        this.current = current;
      }

      Trait.prototype.match = function(text) {
        return this.args = text.match(this.regex);
      };

      return Trait;

    })();
    YearFilter = (function(_super) {

      __extends(YearFilter, _super);

      function YearFilter() {
        return YearFilter.__super__.constructor.apply(this, arguments);
      }

      YearFilter.prototype.regex = /(?:in the year of|of|in) (\d{4})/;

      YearFilter.prototype.run = function(options) {
        if (this.args == null) {
          return options;
        }
        if (this.current.times[this.args[1]] == null) {
          throw new Error('Year ' + this.args[1] + 'is not available');
        }
        options.cut = options.cut || {};
        options.cut['time.year'] = this.args[1];
        return options;
      };

      YearFilter.prototype.buildReply = function() {
        if (this.args == null) {
          return null;
        }
        return "in " + this.args[1];
      };

      return YearFilter;

    })(Trait);
    OrderTrait = (function(_super) {

      __extends(OrderTrait, _super);

      function OrderTrait() {
        return OrderTrait.__super__.constructor.apply(this, arguments);
      }

      OrderTrait.prototype.regex = /by ([\w ]+)/;

      OrderTrait.prototype.run = function(options) {
        var key;
        if (this.args == null) {
          this.args = ['', 'amount'];
        }
        key = findInMapping(this.current, this.args[1]);
        options.order = key;
        return options;
      };

      OrderTrait.prototype.buildReply = function() {
        if (this.args == null) {
          return null;
        }
        return "by " + this.args[1];
      };

      return OrderTrait;

    })(Trait);
    Question = (function() {

      function Question(current) {
        this.current = current;
      }

      Question.prototype.match = function(text) {
        var t, trait, _i, _len, _ref;
        this.text = text;
        this.traits = [];
        _ref = this.traitClasses;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          trait = _ref[_i];
          t = new trait(this.current);
          t.match(text);
          this.traits.push(t);
          if (t.args != null) {
            text = text.replace(t.args[0], '');
          }
        }
        this.args = text.match(this.regex);
        return this.args != null;
      };

      Question.prototype.runTraits = function() {
        var trait, _i, _len, _ref, _results;
        _ref = this.traits;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          trait = _ref[_i];
          _results.push(this.options = trait.run(this.options));
        }
        return _results;
      };

      Question.prototype.interpret = function() {
        this.options = {
          cut: {}
        };
        this.runTraits();
        return this.prepare();
      };

      Question.prototype.getInterpretation = function() {
        this.interpret();
        return this.repr + ' - ' + JSON.stringify(this.options);
      };

      Question.prototype.prepare = function() {};

      Question.prototype.think = function() {
        this.interpret();
        return this.run();
      };

      Question.prototype.getTraitReply = function(data) {
        var reply, trait;
        reply = (function() {
          var _i, _len, _ref, _results;
          _ref = this.traits;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            trait = _ref[_i];
            _results.push(trait.buildReply(data));
          }
          return _results;
        }).call(this);
        reply = reply.join(' ');
        if (reply) {
          return ' ' + reply;
        } else {
          return '';
        }
      };

      Question.prototype.buildReply = function(data) {
        return JSON.stringify(data) + this.getTraitReply(data);
      };

      return Question;

    })();
    AggregateQuestion = (function(_super) {

      __extends(AggregateQuestion, _super);

      function AggregateQuestion() {
        return AggregateQuestion.__super__.constructor.apply(this, arguments);
      }

      AggregateQuestion.prototype.repr = "aggregate";

      AggregateQuestion.prototype.run = function() {
        var d,
          _this = this;
        d = $.Deferred();
        $.when(api.aggregate(this.current.dataset, this.options)).then(function(data) {
          return d.resolve({
            message: _this.buildReply(data),
            data: data,
            html: null
          });
        });
        return d.promise();
      };

      return AggregateQuestion;

    })(Question);
    Who = (function(_super) {

      __extends(Who, _super);

      function Who() {
        return Who.__super__.constructor.apply(this, arguments);
      }

      Who.prototype.traitClasses = [YearFilter, OrderTrait];

      Who.prototype.getDimension = function() {
        return this.args[2];
      };

      Who.prototype.prepare = function() {
        var key;
        this.options.pagesize = 1;
        key = findInMapping(this.current, this.getDimension());
        this.drillDownLabel = this.current.model.mapping[key].label || this.args[2];
        this.options.drilldown = [key];
        return Who.__super__.prepare.apply(this, arguments);
      };

      Who.prototype.run = function() {
        var d,
          _this = this;
        d = $.Deferred();
        $.when(api.aggregate(this.current.dataset, this.options)).then(function(data) {
          return d.resolve({
            message: _this.buildReply(data),
            data: data,
            html: null
          });
        });
        return d.promise();
      };

      Who.prototype.buildReply = function(data) {
        var amount, recipient;
        recipient = data.drilldown[0][this.options.drilldown[0]];
        recipient = recipient.label || recipient.name;
        amount = OpenSpending.Utils.formatAmountWithCommas(data.drilldown[0].amount);
        return "" + recipient + " is the " + this.canonical + " " + this.drillDownLabel + (this.getTraitReply(data)) + " with " + amount + " " + (getCurrenySpeak(data.summary.currency.amount));
      };

      return Who;

    })(Question);
    WhoMax = (function(_super) {

      __extends(WhoMax, _super);

      function WhoMax() {
        return WhoMax.__super__.constructor.apply(this, arguments);
      }

      WhoMax.prototype.regex = /(?:who|what's|(?:(?:what|which) (?:is|was))).* (most|top|biggest|largest) ([\w ]+)/i;

      WhoMax.prototype.canonical = "biggest";

      WhoMax.prototype.prepare = function() {
        this.options.order = this.options.order + ":desc";
        return WhoMax.__super__.prepare.apply(this, arguments);
      };

      return WhoMax;

    })(Who);
    WhoMaxWhich = (function(_super) {

      __extends(WhoMaxWhich, _super);

      function WhoMaxWhich() {
        return WhoMaxWhich.__super__.constructor.apply(this, arguments);
      }

      WhoMaxWhich.prototype.regex = /(?:which|what) ([\w ]+) .*(most|top|biggest|largest)/i;

      WhoMaxWhich.prototype.getDimension = function() {
        return this.args[1];
      };

      return WhoMaxWhich;

    })(WhoMax);
    WhoMin = (function(_super) {

      __extends(WhoMin, _super);

      function WhoMin() {
        return WhoMin.__super__.constructor.apply(this, arguments);
      }

      WhoMin.prototype.regex = /(?:who|what's|(?:(?:what|which) (?:is|was))).* (smallest) ([\w ]+)/i;

      WhoMin.prototype.canonical = "smallest";

      WhoMin.prototype.prepare = function() {
        this.options.order = this.options.order + ":asc";
        return WhoMin.__super__.prepare.apply(this, arguments);
      };

      return WhoMin;

    })(Who);
    WhoMinWhich = (function(_super) {

      __extends(WhoMinWhich, _super);

      function WhoMinWhich() {
        return WhoMinWhich.__super__.constructor.apply(this, arguments);
      }

      WhoMinWhich.prototype.regex = /(?:which|what) ([\w ]+) .*(smallest)/i;

      WhoMinWhich.prototype.getDimension = function() {
        return this.args[1];
      };

      return WhoMinWhich;

    })(WhoMin);
    TotalAmount = (function(_super) {

      __extends(TotalAmount, _super);

      function TotalAmount() {
        return TotalAmount.__super__.constructor.apply(this, arguments);
      }

      TotalAmount.prototype.traitClasses = [YearFilter];

      TotalAmount.prototype.regex = /(?:what(?:'s| is| was)) .*(?:total|received|spent)/i;

      TotalAmount.prototype.buildReply = function(data) {
        var amount, currency, trait;
        amount = data.summary.amount;
        currency = getCurrenySpeak(data.summary.currency.amount);
        trait = this.getTraitReply(data);
        return "The total amount" + trait + " was " + amount + " " + currency;
      };

      return TotalAmount;

    })(AggregateQuestion);
    SearchQuestion = (function(_super) {

      __extends(SearchQuestion, _super);

      function SearchQuestion() {
        return SearchQuestion.__super__.constructor.apply(this, arguments);
      }

      SearchQuestion.prototype.repr = 'search';

      SearchQuestion.prototype.run = function() {
        var d,
          _this = this;
        d = $.Deferred();
        $.when(api.search(this.current.dataset, this.options)).then(function(data) {
          return d.resolve({
            message: _this.buildReply(data),
            data: data,
            html: null
          });
        });
        return d.promise();
      };

      return SearchQuestion;

    })(Question);
    CountQuestion = (function(_super) {

      __extends(CountQuestion, _super);

      function CountQuestion() {
        return CountQuestion.__super__.constructor.apply(this, arguments);
      }

      CountQuestion.prototype.traitClasses = [YearFilter];

      CountQuestion.prototype.regex = /(?:How many) ([\w ]+)/i;

      CountQuestion.prototype.prepare = function() {
        return this.options.drilldown;
      };

      CountQuestion.prototype.prepare = function() {
        var key;
        this.options.pagesize = 1;
        key = findInMapping(this.current, this.args[1]);
        this.drillDownLabel = this.current.model.mapping[key].label || this.args[1];
        this.options.facet_field = key;
        this.options.filter = this.options.cut;
        return CountQuestion.__super__.prepare.apply(this, arguments);
      };

      CountQuestion.prototype.buildReply = function(data) {
        var count, trait;
        count = data.stats.results_count_query;
        trait = this.getTraitReply(data);
        return "There were " + count + " " + this.drillDownLabel + "s" + trait + ".";
      };

      return CountQuestion;

    })(SearchQuestion);
    questions = [CountQuestion, TotalAmount, WhoMax, WhoMaxWhich, WhoMin, WhoMinWhich];
    findQuestion = function(current, text) {
      var q, question, _i, _len;
      for (_i = 0, _len = questions.length; _i < _len; _i++) {
        question = questions[_i];
        q = new question(current);
        if (q.match(text)) {
          return q;
        }
      }
    };
    current = {
      model: null,
      times: null,
      dataset: null
    };
    answerQuestion = function(text, opts) {
      var d, interpretation, question;
      if (opts == null) {
        opts = {};
      }
      opts.speak = true;
      question = findQuestion(current, text);
      if (!question) {
        if (opts.speak) {
          window.speak("Sorry, I don't understand.");
        }
        $("#info").text('Could not interpret');
        return;
      }
      try {
        interpretation = question.getInterpretation();
      } catch (error) {
        if (opts.speak) {
          window.speak(error.message);
        }
        $("#info").append(error.message);
        throw error;
        return;
      }
      $("#info").append(interpretation);
      $('#thinking').show();
      if (opts.speak) {
        window.speak("Let me think about that.");
      }
      d = question.think();
      return $.when(d).then(function(answer) {
        if (opts.speak) {
          window.speak(answer.message);
        }
        $('#answer').text(answer.message);
        $('#thinking').hide();
        return $("#info").append(JSON.stringify(answer));
      });
    };
    $.getJSON(datasetUrl, function(data) {
      $('#dataset-loading').hide();
      $('#dataset-label').fadeIn();
      $("#datasets").html("");
      $("#datasets").append("<option></option>");
      $.each(data.datasets, function(i) {
        var dataset;
        dataset = data.datasets[i];
        return $("#datasets").append("<option value=\"" + dataset.name + "\">" + dataset.label + "</option>");
      });
      $("#datasets").chosen();
      return $("#datasets").change(function(e) {
        var dataset;
        $("#dataset-label").hide();
        $("#speech-label").fadeIn();
        window.setTimeout((function() {
          $("#question").focus();
          $("#dataset-container").hide();
          $("#datasets-form").append($("#dataset-container"));
          $("#dataset-container").fadeIn();
          return $("#dataset-label").remove();
        }), 500);
        dataset = $(this).val();
        if (!dataset) {
          return;
        }
        current.dataset = dataset;
        getModel(dataset).then(function(data) {
          var dim, key, _results;
          current.model = data;
          dim = $("#dimensions").html("");
          _results = [];
          for (key in data.mapping) {
            _results.push(dim.append($("<li>").text(data.mapping[key].label)));
          }
          return _results;
        });
        return getTime(dataset).then(function(data) {
          var key, value, years, _results;
          current.times = data;
          years = $('#years').html('');
          _results = [];
          for (key in data) {
            value = data[key];
            _results.push(years.append($("<li>").text(key)));
          }
          return _results;
        });
      });
    });
    $("#question").on("webkitspeechchange", function() {
      return answerQuestion($(this).val(), {
        speak: true
      });
    });
    $("#question").keydown(function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        return answerQuestion($("#question").val());
      }
    });
    return findLeastLevenshtein = function(haystack, needle) {};
  });

}).call(this);
